"""
ElliotOS Slack Bot
Handles posting morning and evening digests to Slack channels
"""

import json
from datetime import datetime
from typing import Dict, Any, Optional

from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
import requests

from config.settings import settings
from utils.logger import get_logger

logger = get_logger("slack_bot")

class ElliotSlackBot:
    """Main Slack bot for ElliotOS"""
    
    def __init__(self):
        self.clients = []
        self.webhook_url = settings.SLACK_WEBHOOK_URL
        self.summary_channel = settings.SLACK_SUMMARY_CHANNEL
        self._setup_clients()
    
    def _setup_clients(self):
        """Setup Slack clients for posting"""
        
        # Setup bot token clients
        for token in settings.SLACK_BOT_TOKENS:
            if token:
                try:
                    client = WebClient(token=token)
                    # Test the connection
                    response = client.auth_test()
                    self.clients.append({
                        "client": client,
                        "team": response.get("team", "Unknown"),
                        "bot_id": response.get("user_id", "")
                    })
                    logger.success(f"Connected Slack bot to: {response.get('team', 'Unknown')}")
                except SlackApiError as e:
                    logger.error(f"Failed to setup Slack bot: {e}")
    
    def post_morning_digest(self, digest_content: str, context_data: Dict[str, Any] = None) -> bool:
        """Post morning digest to Slack"""
        
        logger.info("Posting morning digest to Slack")
        
        # Format the message with rich formatting
        formatted_message = self._format_morning_message(digest_content, context_data)
        
        # Try posting via bot clients first
        if self._post_via_bot_clients(formatted_message):
            return True
        
        # Fallback to webhook
        if self.webhook_url:
            return self._post_via_webhook(formatted_message)
        
        logger.error("No valid Slack posting method available")
        return False
    
    def post_evening_digest(self, digest_content: str, context_data: Dict[str, Any] = None) -> bool:
        """Post evening digest to Slack"""
        
        logger.info("Posting evening digest to Slack")
        
        # Format the message with rich formatting
        formatted_message = self._format_evening_message(digest_content, context_data)
        
        # Try posting via bot clients first
        if self._post_via_bot_clients(formatted_message):
            return True
        
        # Fallback to webhook
        if self.webhook_url:
            return self._post_via_webhook(formatted_message)
        
        logger.error("No valid Slack posting method available")
        return False
    
    def _format_morning_message(self, content: str, context_data: Dict[str, Any] = None) -> Dict[str, Any]:
        """Format morning digest for Slack"""
        
        current_time = datetime.now().strftime("%A, %B %d at %I:%M %p")
        
        # Create rich Slack message with blocks
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"ðŸŒ… Good Morning, Elliot! - {current_time}"
                }
            },
            {
                "type": "divider"
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": content
                }
            }
        ]
        
        # Add quick stats if context data available
        if context_data:
            stats_text = self._generate_quick_stats(context_data)
            if stats_text:
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*ðŸ“Š Quick Stats:*\n{stats_text}"
                    }
                })
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "Generated by ElliotOS ðŸ¤– | Have a productive day!"
                }
            ]
        })
        
        return {
            "channel": self.summary_channel,
            "blocks": blocks,
            "text": f"Morning Digest - {current_time}",  # Fallback text
            "username": "ElliotOS",
            "icon_emoji": ":sunrise:"
        }
    
    def _format_evening_message(self, content: str, context_data: Dict[str, Any] = None) -> Dict[str, Any]:
        """Format evening digest for Slack"""
        
        current_time = datetime.now().strftime("%A, %B %d at %I:%M %p")
        
        # Create rich Slack message with blocks
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"ðŸŒ™ Good Evening, Elliot! - {current_time}"
                }
            },
            {
                "type": "divider"
            },
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": content
                }
            }
        ]
        
        # Add daily summary if context data available
        if context_data:
            summary_text = self._generate_daily_summary(context_data)
            if summary_text:
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*ðŸ“ˆ Today's Summary:*\n{summary_text}"
                    }
                })
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "Generated by ElliotOS ðŸ¤– | Rest well!"
                }
            ]
        })
        
        return {
            "channel": self.summary_channel,
            "blocks": blocks,
            "text": f"Evening Digest - {current_time}",  # Fallback text
            "username": "ElliotOS",
            "icon_emoji": ":crescent_moon:"
        }
    
    def _generate_quick_stats(self, context_data: Dict[str, Any]) -> str:
        """Generate quick stats for morning message"""
        
        stats = []
        
        # Calendar stats
        if "calendar" in context_data:
            calendar_data = context_data["calendar"]
            today_events = len(calendar_data.get("today_events", []))
            if today_events > 0:
                stats.append(f"ðŸ“… {today_events} events today")
        
        # Health stats
        if "health" in context_data:
            health_data = context_data["health"]
            if "sleep" in health_data and health_data["sleep"].get("last_night"):
                sleep_hours = health_data["sleep"]["last_night"].get("total_hours", 0)
                stats.append(f"ðŸ˜´ {sleep_hours}h sleep")
        
        # Slack stats
        if "slack" in context_data:
            slack_data = context_data["slack"]
            if "aggregated" in slack_data:
                unread = slack_data["aggregated"].get("total_unread", 0)
                mentions = slack_data["aggregated"].get("total_mentions", 0)
                if unread > 0 or mentions > 0:
                    stats.append(f"ðŸ’¬ {mentions} mentions, {unread} unread")
        
        return " â€¢ ".join(stats)
    
    def _generate_daily_summary(self, context_data: Dict[str, Any]) -> str:
        """Generate daily summary for evening message"""
        
        summary = []
        
        # Productivity summary
        if "mac_stats" in context_data:
            mac_data = context_data["mac_stats"]
            if "productivity_metrics" in mac_data:
                focus_score = mac_data["productivity_metrics"].get("focus_score", 0)
                summary.append(f"ðŸŽ¯ Focus Score: {focus_score}/10")
        
        # Health summary
        if "health" in context_data:
            health_data = context_data["health"]
            if "steps" in health_data:
                steps = health_data["steps"].get("today_steps", 0)
                goal = health_data["steps"].get("goal", 10000)
                if steps >= goal:
                    summary.append(f"ðŸ‘Ÿ Step goal achieved! ({steps:,})")
                else:
                    summary.append(f"ðŸ‘Ÿ {steps:,} steps ({goal-steps:,} short)")
        
        # Activity summary
        if "health" in context_data and "activity" in context_data["health"]:
            activity = context_data["health"]["activity"]
            rings_closed = activity.get("total_rings_closed", 0)
            summary.append(f"ðŸŽ¯ {rings_closed}/3 activity rings closed")
        
        return " â€¢ ".join(summary)
    
    def _post_via_bot_clients(self, message: Dict[str, Any]) -> bool:
        """Post message via bot clients"""
        
        if not self.clients:
            return False
        
        success = False
        
        for client_info in self.clients:
            try:
                client = client_info["client"]
                
                response = client.chat_postMessage(**message)
                
                if response.get("ok"):
                    logger.success(f"Posted to {client_info['team']} via bot")
                    success = True
                else:
                    logger.error(f"Failed to post to {client_info['team']}: {response.get('error')}")
                    
            except SlackApiError as e:
                logger.error(f"Slack API error for {client_info['team']}: {e}")
                continue
        
        return success
    
    def _post_via_webhook(self, message: Dict[str, Any]) -> bool:
        """Post message via webhook"""
        
        try:
            # Convert blocks format to webhook format
            webhook_payload = {
                "channel": message.get("channel"),
                "username": message.get("username", "ElliotOS"),
                "icon_emoji": message.get("icon_emoji", ":robot_face:"),
                "blocks": message.get("blocks", [])
            }
            
            response = requests.post(
                self.webhook_url,
                json=webhook_payload,
                timeout=10
            )
            
            if response.status_code == 200:
                logger.success("Posted via webhook")
                return True
            else:
                logger.error(f"Webhook failed: {response.status_code}")
                return False
                
        except Exception as e:
            logger.error(f"Webhook error: {e}")
            return False
    
    def post_custom_message(self, message: str, channel: Optional[str] = None) -> bool:
        """Post a custom message to Slack"""
        
        target_channel = channel or self.summary_channel
        
        simple_message = {
            "channel": target_channel,
            "text": message,
            "username": "ElliotOS",
            "icon_emoji": ":robot_face:"
        }
        
        # Try bot clients first
        if self._post_via_bot_clients(simple_message):
            return True
        
        # Fallback to webhook
        if self.webhook_url:
            return self._post_via_webhook(simple_message)
        
        return False
    
    def test_connection(self) -> Dict[str, Any]:
        """Test Slack connection and return status"""
        
        status = {
            "bot_clients": len(self.clients),
            "webhook_configured": bool(self.webhook_url),
            "can_post": len(self.clients) > 0 or bool(self.webhook_url),
            "teams": [client["team"] for client in self.clients]
        }
        
        return status

# Global bot instance
slack_bot = ElliotSlackBot() 